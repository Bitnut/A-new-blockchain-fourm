{"version":3,"sources":["../../../src/app/utils/ProxifyUrl.js"],"names":["rProxyDomain","rProxyDomainsDimensions","NATURAL_SIZE","CAPPED_SIZE","imageProxy","$STM_Config","img_proxy_prefix","url","dimensions","proxyList","match","respUrl","lastProxy","length","substring","lastIndexOf","dims","shift","test"],"mappings":";;;;;AAAA;AACA;;;;;;;;;AASA,IAAMA,eAAe,gDAArB;AACA,IAAMC,0BAA0B,gEAAhC;AACA,IAAMC,eAAe,MAArB;AACA,IAAMC,cAAc,QAApB;;AAEO,IAAMC,kCAAa,SAAbA,UAAa;AAAA,WAAMC,YAAYC,gBAAlB;AAAA,CAAnB;;AAEP;;;;;;;;;kBAQe,UAACC,GAAD,EAA6B;AAAA,QAAvBC,UAAuB,uEAAV,KAAU;;AACxC,QAAMC,YAAYF,IAAIG,KAAJ,CAAUT,uBAAV,CAAlB;AACA,QAAIU,UAAUJ,GAAd;AACA,QAAIE,SAAJ,EAAe;AACX,YAAMG,YAAYH,UAAUA,UAAUI,MAAV,GAAmB,CAA7B,CAAlB;AACAF,kBAAUJ,IAAIO,SAAJ,CAAcP,IAAIQ,WAAJ,CAAgBH,SAAhB,IAA6BA,UAAUC,MAArD,CAAV;AACH;AACD,QAAIL,cAAcH,WAAd,IAA6BA,YAAYC,gBAA7C,EAA+D;AAC3D,YAAIU,OAAOR,aAAa,GAAxB;AACA,YAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAChCQ,mBAAOP,YACDA,UAAUQ,KAAV,GAAkBP,KAAlB,CAAwB,oBAAxB,EAA8C,CAA9C,CADC,GAEDR,YAFN;AAGH;;AAED;AACA;AACA,YAAI,CAACS,QAAQD,KAAR,CAAc,QAAd,CAAD,IAA4BM,SAASd,YAAzC,EAAuD;AACnDc,mBAAOb,WAAP;AACH;;AAED,YACKD,iBAAiBc,IAAjB,IAAyBb,gBAAgBa,IAA1C,IACA,CAAChB,aAAakB,IAAb,CAAkBP,OAAlB,CAFL,EAGE;AACE,mBAAON,YAAYC,gBAAZ,GAA+BU,IAA/B,GAAsCL,OAA7C;AACH;AACJ;AACD,WAAOA,OAAP;AACH,C","file":"ProxifyUrl.js","sourcesContent":["/*global $STM_Config:false*/\n/**\n * this regular expression should capture all possible proxy domains\n * Possible URL schemes are:\n * <proxy>/<file url>\n * <proxy>/{int}x{int}/<external domain and file url>\n * <proxy>/{int}x{int}/[...<proxy>/{int}x{int}/]<external domain and file url>\n * <proxy>/{int}x{int}/[<proxy>/{int}x{int}/]<proxy>/<file url>\n * @type {RegExp}\n */\nconst rProxyDomain = /^http(s)?:\\/\\/steemit(dev|stage)?images.com\\//g;\nconst rProxyDomainsDimensions = /http(s)?:\\/\\/steemit(dev|stage)?images.com\\/([0-9]+x[0-9]+)\\//g;\nconst NATURAL_SIZE = '0x0/';\nconst CAPPED_SIZE = '640x0/';\n\nexport const imageProxy = () => $STM_Config.img_proxy_prefix;\n\n/**\n * Strips all proxy domains from the beginning of the url. Adds the global proxy if dimension is specified\n * @param {string} url\n * @param {string|boolean} dimensions - optional -  if provided. url is proxied && global var $STM_Config.img_proxy_prefix is avail. resp will be \"$STM_Config.img_proxy_prefix{dimensions}/{sanitized url}\"\n *                                          if falsy, all proxies are stripped.\n *                                          if true, preserves the first {int}x{int} in a proxy url. If not found, uses 0x0\n * @returns string\n */\nexport default (url, dimensions = false) => {\n    const proxyList = url.match(rProxyDomainsDimensions);\n    let respUrl = url;\n    if (proxyList) {\n        const lastProxy = proxyList[proxyList.length - 1];\n        respUrl = url.substring(url.lastIndexOf(lastProxy) + lastProxy.length);\n    }\n    if (dimensions && $STM_Config && $STM_Config.img_proxy_prefix) {\n        let dims = dimensions + '/';\n        if (typeof dimensions !== 'string') {\n            dims = proxyList\n                ? proxyList.shift().match(/([0-9]+x[0-9]+)\\//g)[0]\n                : NATURAL_SIZE;\n        }\n\n        // NOTE: This forces the dimensions to be `CAPPED_SIZE` to save on\n        // bandwidth costs. Do not modify gifs.\n        if (!respUrl.match(/\\.gif$/) && dims === NATURAL_SIZE) {\n            dims = CAPPED_SIZE;\n        }\n\n        if (\n            (NATURAL_SIZE !== dims && CAPPED_SIZE !== dims) ||\n            !rProxyDomain.test(respUrl)\n        ) {\n            return $STM_Config.img_proxy_prefix + dims + respUrl;\n        }\n    }\n    return respUrl;\n};\n"]}