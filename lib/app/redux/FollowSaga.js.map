{"version":3,"sources":["../../../src/app/redux/FollowSaga.js"],"names":["fetchFollowCount","loadFollows","globalActions","loadFollowsLoop","account","api","getFollowCountAsync","counts","update","key","updater","m","mergeDeep","follower_count","following_count","method","type","force","state","global","getIn","hasIn","hasResult","notSet","set","start","limit","fromJS","res","cnt","lastAccountName","asMutable","forEach","whatList","value","get","accountNameKey","accountName","what","s","add","asImmutable","result","deleteIn","updateIn","mm","merge","size","reverse"],"mappings":"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","file":"FollowSaga.js","sourcesContent":["import { fromJS, Map, Set, OrderedSet } from 'immutable';\nimport { call, put, select } from 'redux-saga/effects';\nimport { api } from '@steemit/steem-js';\n\nimport * as globalActions from 'app/redux/GlobalReducer';\n\n/**\n    This loadFollows both 'blog' and 'ignore'\n*/\n\n//fetch for follow/following count\nexport function* fetchFollowCount(account) {\n    const counts = yield call([api, api.getFollowCountAsync], account);\n    yield put(\n        globalActions.update({\n            key: ['follow_count', account],\n            updater: m =>\n                m.mergeDeep({\n                    follower_count: counts.follower_count,\n                    following_count: counts.following_count,\n                }),\n        })\n    );\n}\n\n// Test limit with 2 (not 1, infinate looping)\nexport function* loadFollows(method, account, type, force = false) {\n    if (\n        yield select(state =>\n            state.global.getIn(['follow', method, account, type + '_loading'])\n        )\n    ) {\n        // console.log('Already loading', method, account, type)\n        return;\n    }\n\n    if (!force) {\n        const hasResult = yield select(state =>\n            state.global.hasIn(['follow', method, account, type + '_result'])\n        );\n        if (hasResult) {\n            // console.log('Already loaded', method, account, type)\n            return;\n        }\n    }\n\n    yield put(\n        globalActions.update({\n            key: ['follow', method, account],\n            notSet: Map(),\n            updater: m => m.set(type + '_loading', true),\n        })\n    );\n\n    yield loadFollowsLoop(method, account, type);\n}\n\nfunction* loadFollowsLoop(method, account, type, start = '', limit = 1000) {\n    const res = fromJS(yield api[method](account, start, type, limit));\n    // console.log('res.toJS()', res.toJS())\n\n    let cnt = 0;\n    let lastAccountName = null;\n\n    yield put(\n        globalActions.update({\n            key: ['follow_inprogress', method, account],\n            notSet: Map(),\n            updater: m => {\n                m = m.asMutable();\n                res.forEach(value => {\n                    cnt += 1;\n\n                    const whatList = value.get('what');\n                    const accountNameKey =\n                        method === 'getFollowingAsync'\n                            ? 'following'\n                            : 'follower';\n                    const accountName = (lastAccountName = value.get(\n                        accountNameKey\n                    ));\n                    whatList.forEach(what => {\n                        //currently this is always true: what === type\n                        m.update(what, OrderedSet(), s => s.add(accountName));\n                    });\n                });\n                return m.asImmutable();\n            },\n        })\n    );\n\n    if (cnt === limit) {\n        // This is paging each block of up to limit results\n        yield call(loadFollowsLoop, method, account, type, lastAccountName);\n    } else {\n        // This condition happens only once at the very end of the list.\n        // Every account has a different followers and following list for: blog, ignore\n        yield put(\n            globalActions.update({\n                key: [],\n                updater: m => {\n                    m = m.asMutable();\n\n                    const result = m.getIn(\n                        ['follow_inprogress', method, account, type],\n                        OrderedSet()\n                    );\n                    m.deleteIn(['follow_inprogress', method, account, type]);\n                    m.updateIn(['follow', method, account], Map(), mm =>\n                        mm.merge({\n                            // Count may be set separately without loading the full xxx_result set\n                            [type + '_count']: result.size,\n                            [type + '_result']: result.reverse(),\n                            [type + '_loading']: false,\n                        })\n                    );\n                    return m.asImmutable();\n                },\n            })\n        );\n    }\n}\n"]}